import path from "path";
import axios from "axios";
import process from "process";
import yaml from "js-yaml";
import readline from "readline";
import AdmZip from "adm-zip";
import zlib from "zlib";
import fs from "fs";
import { fileURLToPath } from "url";
import { readFile, writeFile, mkdir } from "fs/promises";
import { spawn } from "child_process";
import { logger } from "../logger.js";

// proxy parameters
const PROXY_SERVER = "127.0.0.1:7890";
const PROXY_OVERRIDE =
  "localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;192.168.*";

const __filename = fileURLToPath(import.meta.url);

/**
 * è§£å‹ .gz æ–‡ä»¶åˆ°æŒ‡å®šè·¯å¾„
 * @param {string} gzFilePath - .gz æ–‡ä»¶è·¯å¾„
 * @param {string} outputFilePath - è§£å‹åçš„æ–‡ä»¶è·¯å¾„
 * @returns {Promise<void>}
 */
async function decompressGzFile(gzFilePath, outputFilePath) {
  return new Promise((resolve, reject) => {
    const input = fs.createReadStream(gzFilePath);
    const output = fs.createWriteStream(outputFilePath);
    const gunzip = zlib.createGunzip();

    input.pipe(gunzip).pipe(output);

    output.on("finish", () => {
      logger.info(`æ–‡ä»¶å·²æˆåŠŸè§£å‹åˆ° ${outputFilePath}`, "clash_init.js");
      resolve();
    });

    output.on("error", (error) => {
      logger.error(`è§£å‹æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, "clash_init.js");
      reject(error);
    });
  });
}

/**
 * @param {string} ä¸Šçº§ç›®å½•
 * @returns {Promise<void>}
 */
async function downloadMihomoCore(targetPath) {
  const version = "v1.19.10";
  const platform = process.platform;
  const arch = process.arch;

  const gzFilePath = path.join(path.dirname(targetPath), "mihomo.gz");
  const zipFilePath = path.join(path.dirname(targetPath), "mihomo.zip");

  //https://github.com/MetaCubeX/mihomo/releases/download/v1.19.10/mihomo-darwin-amd64-v1.19.10.gz
  //https://github.com/MetaCubeX/mihomo/releases/download/v1.19.10/mihomo-windows-amd64-v1.19.10.zip
  let downloadUrl = `https://github.com/MetaCubeX/mihomo/releases/download/${version}/mihomo-windows-amd64-${version}.zip`;
  logger.info(`æ­£åœ¨ä» ${downloadUrl} ä¸‹è½½ mihomo æ ¸å¿ƒ...`, "clash_init.js");
  try {
    const response = await axios.get(downloadUrl, {
      responseType: "arraybuffer",
    });
    // await writeFile(gzFilePath, Buffer.from(response.data));
    await writeFile(zipFilePath, Buffer.from(response.data));
    logger.info(`mihomo æ ¸å¿ƒå·²æˆåŠŸä¸‹è½½åˆ° ${zipFilePath}`, "clash_init.js");
    logger.info("æ­£åœ¨è§£å‹ mihomo æ ¸å¿ƒ...", "clash_init.js");
    // await decompressGzFile(gzFilePath, targetPath);
    const zip = new AdmZip(zipFilePath);
    zip.extractAllTo(path.dirname(targetPath), true);
    logger.info(`mihomo æ ¸å¿ƒå·²æˆåŠŸè§£å‹åˆ° ${targetPath}`, "clash_init.js");
  } catch (error) {
    logger.error(`ä¸‹è½½ mihomo æ ¸å¿ƒæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, "clash_init.js");
    throw error;
  }
}

const __dirname = path.dirname(__filename);
const urlFilePath = path.join(__dirname, "url.txt");
const clashExecutablePath = path.join(__dirname, "mihomo-windows-amd64.exe");

/**
 * ä¸‹è½½Clashé…ç½®æ–‡ä»¶
 * @param {string} configUrl - é…ç½®æ–‡ä»¶URL
 * @param {string} baseDir - åŸºç¡€ç›®å½•è·¯å¾„
 * @returns {Promise<string>} ä¸‹è½½çš„é…ç½®æ–‡ä»¶è·¯å¾„
 */
async function fetchConfig(configUrl, baseDir) {
  try {
    const encodedUrlHash = Buffer.from(configUrl)
      .toString("base64")
      .replace(/[\\/:*?"<>|]/g, "_");
    const configDirectory = path.join(baseDir, encodedUrlHash);
    const downloadedConfigPath = path.join(configDirectory, "config.yaml");

    await mkdir(configDirectory, { recursive: true });
    const response = await axios.get(configUrl, { responseType: "text" });
    await writeFile(downloadedConfigPath, response.data);

    logger.info(`é…ç½®æ–‡ä»¶å·²æˆåŠŸä¿å­˜åˆ° ${downloadedConfigPath}`, "clash_init.js");
    return downloadedConfigPath;
  } catch (error) {
    logger.error(`è·å–é…ç½®æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, "clash_init.js");
    throw error;
  }
}
async function clearSystemProxy() {
  return new Promise((resolve) => {
    logger.info("å‡†å¤‡æ¸…é™¤ç³»ç»Ÿä»£ç†è®¾ç½®...", "clash_init.js");
    const ps = spawn("powershell.exe", [
      "-Command",
      `
        # è®¾ç½®è¾“å‡ºç¼–ç ä¸º UTF-8
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        
        # ç¦ç”¨ä»£ç†
        Set-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings' -name ProxyEnable -value 0
        
        # åˆ·æ–°ä»£ç†è®¾ç½®
        $signature = @"
[DllImport("wininet.dll", SetLastError = true, CharSet=CharSet.Auto)]
public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int lpdwBufferLength);
"@
        $type = Add-Type -MemberDefinition $signature -Name wininet -Namespace pinvoke -PassThru
        $null = $type::InternetSetOption([IntPtr]::Zero, 39, [IntPtr]::Zero, 0)  // 39 = INTERNET_OPTION_SETTINGS_CHANGED
        $null = $type::InternetSetOption([IntPtr]::Zero, 37, [IntPtr]::Zero, 0)  // 37 = INTERNET_OPTION_REFRESH
      `,
    ]);

    ps.stdout.on("data", (data) => {
      logger.info(`[PowerShell]: ${data}`, "clash_init.js");
    });

    ps.stderr.on("data", (data) => {
      logger.error(`[PowerShell error]: ${data}`, "clash_init.js");
    });

    ps.on("close", (code) => {
      if (code === 0) {
        logger.info("PowerShellè„šæœ¬æ‰§è¡ŒæˆåŠŸ", "clash_init.js");
        resolve(true);
      } else {
        logger.error(`PowerShellè„šæœ¬æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºç : ${code}`, "clash_init.js");
        resolve(false);
      }
    });
  });
}

async function setSystemProxy() {
  logger.info("å‡†å¤‡è®¾ç½®ç³»ç»Ÿä»£ç†...", "clash_init.js");
  return new Promise((resolve) => {
    const ps = spawn("powershell.exe", [
      "-Command",
      `
        # è®¾ç½®è¾“å‡ºç¼–ç ä¸º UTF-8
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        
        # è®¾ç½®ä»£ç†æ³¨å†Œè¡¨é¡¹
        Set-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings' -name ProxyEnable -value 1
        Set-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings' -name ProxyServer -value "${PROXY_SERVER}"
        Set-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings' -name ProxyOverride -value "${PROXY_OVERRIDE}"
        
        # åˆ·æ–°ä»£ç†è®¾ç½®
        $signature = @"
[DllImport("wininet.dll", SetLastError = true, CharSet=CharSet.Auto)]
public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int lpdwBufferLength);
"@
        $type = Add-Type -MemberDefinition $signature -Name wininet -Namespace pinvoke -PassThru
        $null = $type::InternetSetOption([IntPtr]::Zero, 39, [IntPtr]::Zero, 0)  // 39 = INTERNET_OPTION_SETTINGS_CHANGED
        $null = $type::InternetSetOption([IntPtr]::Zero, 37, [IntPtr]::Zero, 0)  // 37 = INTERNET_OPTION_REFRESH
      `,
    ]);

    ps.stdout.on("data", (data) => {
      logger.info(`[PowerShell]: ${data}`, "clash_init.js");
    });

    ps.stderr.on("data", (data) => {
      logger.error(`[PowerShell error]: ${data}`, "clash_init.js");
    });

    ps.on("close", (code) => {
      if (code === 0) {
        logger.info("PowerShellè„šæœ¬æ‰§è¡ŒæˆåŠŸ", "clash_init.js");
        resolve(true);
      } else {
        logger.error(`PowerShellè„šæœ¬æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºç : ${code}`, "clash_init.js");
        resolve(false);
      }
    });
  });
}

(async () => {
  try {
    // è¯»å–URLåˆ—è¡¨æ–‡ä»¶
    const urlListContent = await readFile(urlFilePath, "utf-8");
    const availableUrls = urlListContent
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.length > 0);

    if (availableUrls.length === 0) {
      logger.error("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„é…ç½®æ–‡ä»¶URLï¼Œè¯·æ£€æŸ¥url.txtæ–‡ä»¶", "clash_init.js");
      return;
    }

    // æ˜¾ç¤ºURLé€‰é¡¹
    logger.info("è¯·é€‰æ‹©é…ç½®æ–‡ä»¶ç¼–å·ï¼š", "clash_init.js");
    availableUrls.forEach((url, index) => {
      logger.info(`${index + 1}. ${url}`, "clash_init.js");
    });

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    // è·å–ç”¨æˆ·é€‰æ‹©
    const selectedIndex = await new Promise((resolve) => {
      rl.question("è¾“å…¥ç¼–å·: ", (answer) => {
        rl.close();
        const index = parseInt(answer) - 1;
        resolve(index);
      });
    });

    // éªŒè¯é€‰æ‹©æœ‰æ•ˆæ€§
    if (
      isNaN(selectedIndex) ||
      selectedIndex < 0 ||
      selectedIndex >= availableUrls.length
    ) {
      logger.error("æ— æ•ˆçš„é€‰æ‹©", "clash_init.js");
      return;
    }

    const selectedConfigUrl = availableUrls[selectedIndex];
    logger.info(`æ­£åœ¨è·å–é…ç½®æ–‡ä»¶: ${selectedConfigUrl}`, "clash_init.js");

    // ä¸‹è½½é…ç½®æ–‡ä»¶
    const downloadedConfigPath = await fetchConfig(
      selectedConfigUrl,
      __dirname
    );

    // mihomoæ ¸å¿ƒä¸‹è½½é€»è¾‘ ---
    const coreExists = await readFile(clashExecutablePath)
      .then(() => true)
      .catch(() => false); // æ£€æŸ¥æ ¸å¿ƒå¯æ‰§è¡Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨

    if (!coreExists) {
      logger.info("æœªæ‰¾åˆ° mihomo æ ¸å¿ƒï¼Œæ­£åœ¨å°è¯•ä¸‹è½½...", "clash_init.js");
      try {
        await downloadMihomoCore(clashExecutablePath);
      } catch (downloadError) {
        logger.error(
          `ä¸‹è½½ mihomo æ ¸å¿ƒå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨ä¸‹è½½å¹¶æ”¾ç½®åˆ°æŒ‡å®šä½ç½®: ${clashExecutablePath}`,
          "clash_init.js"
        );
      }
    } else {
      logger.info("å·²æ‰¾åˆ° mihomo æ ¸å¿ƒï¼Œè·³è¿‡ä¸‹è½½ã€‚", "clash_init.js");
    }

    // è¯»å–å¹¶è§£æé…ç½®æ–‡ä»¶
    const configContent = await readFile(downloadedConfigPath, "utf-8");
    const clashConfig = yaml.load(configContent);
    const proxyPort = clashConfig.port;
    const externalController = clashConfig["external-controller"];

    logger.info(`ä»£ç†ç«¯å£: ${proxyPort}`, "clash_init.js");
    logger.info(`å¤–éƒ¨æ§åˆ¶å™¨: ${externalController}`, "clash_init.js");

    logger.info("å¯åŠ¨ Clash æœåŠ¡...", "clash_init.js");
    // åœ¨å¯åŠ¨å‰å†æ¬¡æ£€æŸ¥æ ¸å¿ƒæ–‡ä»¶æ˜¯å¦å­˜åœ¨
    const finalCoreExists = await readFile(clashExecutablePath)
      .then(() => true)
      .catch(() => false);

    if (!finalCoreExists) {
      logger.error(
        "mihomo æ ¸å¿ƒä¸å­˜åœ¨ï¼Œæ— æ³•å¯åŠ¨æœåŠ¡ã€‚è¯·ç¡®ä¿æ ¸å¿ƒæ–‡ä»¶å·²ä¸‹è½½æˆ–æ”¾ç½®åœ¨æ­£ç¡®ä½ç½®ã€‚",
        "clash_init.js"
      );
      return; // å¦‚æœæ ¸å¿ƒæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™é€€å‡ºç¨‹åº
    }

    const clashProcess = spawn(clashExecutablePath, [
      "-d",
      path.dirname(downloadedConfigPath),
    ]);
    logger.info(`Clashè¿›ç¨‹ID: ${clashProcess.pid}`, "clash_init.js");

    clashProcess.stdout.on("data", (data) => {
      logger.info(`[clash]: ${data.toString().trim()}`, "clash_init.js");
    });

    clashProcess.stderr.on("data", (data) => {
      logger.error(`[clash error]: ${data.toString().trim()}`, "clash_init.js");
    });

    // ç­‰å¾…Clashå¯åŠ¨
    await new Promise((resolve) => setTimeout(resolve, 2000));

    logger.info("è®¾ç½®ç³»ç»Ÿä»£ç†...", "clash_init.js");
    const proxySetSuccess = await setSystemProxy();

    if (proxySetSuccess) {
      logger.info("ä»£ç†è®¾ç½®æˆåŠŸ", "clash_init.js");

      // æ·»åŠ èŠ‚ç‚¹é€‰æ‹©åŠŸèƒ½
      try {
        const selectGroup = clashConfig["proxy-groups"].find(
          (group) => group.name === "ğŸ”° é€‰æ‹©èŠ‚ç‚¹"
        );

        if (selectGroup) {
          logger.info("\nèŠ‚ç‚¹åˆ—è¡¨ï¼š", "clash_init.js");
          const proxiesInfo = [];

          // æµ‹è¯•å¹¶æ˜¾ç¤ºèŠ‚ç‚¹å»¶è¿Ÿ
          for (const proxyName of selectGroup.proxies) {
            if (proxyName === "DIRECT") continue;

            try {
              const proxy = clashConfig.proxies.find(
                (p) => p.name === proxyName
              );
              if (!proxy) continue;

              // æµ‹è¯•å»¶è¿Ÿ
              const startTime = Date.now();
              await axios.get("http://www.gstatic.com/generate_204", {
                proxy: {
                  host: "127.0.0.1",
                  port: proxyPort,
                },
                timeout: 5000,
              });
              const latency = Date.now() - startTime;

              proxiesInfo.push({
                name: proxyName,
                server: proxy.server,
                latency: latency,
              });

              logger.info(`${proxyName} - ${latency}ms`, "clash_init.js");
            } catch (error) {
              logger.info(`${proxyName} - è¶…æ—¶`, "clash_init.js");
              proxiesInfo.push({
                name: proxyName,
                server: proxy.server,
                latency: -1,
              });
            }
          }

          // åˆ›å»ºæ–°çš„readlineæ¥å£ç”¨äºèŠ‚ç‚¹é€‰æ‹©
          const rlNode = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
          });

          // è·å–ç”¨æˆ·é€‰æ‹©çš„èŠ‚ç‚¹
          const selectedNodeIndex = await new Promise((resolve) => {
            rlNode.question(
              "\nè¯·é€‰æ‹©è¦ä½¿ç”¨çš„èŠ‚ç‚¹ç¼–å·ï¼ˆè¾“å…¥0å–æ¶ˆï¼‰: ",
              (answer) => {
                rlNode.close();
                resolve(parseInt(answer) - 1);
              }
            );
          });

          if (
            selectedNodeIndex >= 0 &&
            selectedNodeIndex < proxiesInfo.length
          ) {
            const selectedProxy = proxiesInfo[selectedNodeIndex];
            logger.info(`æ­£åœ¨åˆ‡æ¢åˆ°èŠ‚ç‚¹: ${selectedProxy.name}`, "clash_init.js");

            // é€šè¿‡APIåˆ‡æ¢èŠ‚ç‚¹
            await axios.put(
              `http://${externalController}/proxies/ğŸ”° é€‰æ‹©èŠ‚ç‚¹`,
              {
                name: selectedProxy.name,
              }
            );

            logger.info("èŠ‚ç‚¹åˆ‡æ¢æˆåŠŸ", "clash_init.js");
          }
        }
      } catch (error) {
        logger.error(`èŠ‚ç‚¹é€‰æ‹©å‡ºé”™: ${error.message}`, "clash_init.js");
      }
    } else {
      logger.info("ä»£ç†è®¾ç½®å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨è®¾ç½®:", "clash_init.js");
      logger.info("æ‰“å¼€Windowsè®¾ç½® -> ç½‘ç»œå’ŒInternet -> ä»£ç†", "clash_init.js");
      logger.info(
        `åœ°å€: ${PROXY_SERVER.split(":")[0]}, ç«¯å£: ${PROXY_SERVER.split(":")[1]}`,
        "clash_init.js"
      );
      logger.info(`ä¾‹å¤–åˆ—è¡¨: ${PROXY_OVERRIDE}`, "clash_init.js");
    }

    // æ³¨å†Œè¿›ç¨‹é€€å‡ºå¤„ç†
    process.on("exit", () => {
      if (!clashProcess.killed) {
        clashProcess.kill("SIGKILL");
      }
    });

    process.on("SIGINT", async () => {
      logger.info("\næ­£åœ¨å…³é—­æœåŠ¡...", "clash_init.js");
      if (!clashProcess.killed) {
        clashProcess.kill("SIGINT");
      }
      logger.info("æ­£åœ¨æ¸…é™¤ç³»ç»Ÿä»£ç†è®¾ç½®...", "clash_init.js");
      await clearSystemProxy();
      process.exit();
    });
  } catch (error) {
    logger.error(`ç¨‹åºè¿è¡Œå‡ºé”™: ${error.message}`, "clash_init.js");
  }
})();